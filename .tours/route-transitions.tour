{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "Route transition",
  "steps": [
    {
      "file": "demo-app/app/router.js",
      "description": "# Introduction\nOne common scenario for animation is transitioning from one route to another while preserving shared UI elements. In this demo, we'll be exploring how we can animate a link as we transition from `/routes` to `/routes/other`.\n\n![Shows a page transition. After clicking on the link, the link's old content slides over horizontally to allow new content from the new route to replace it.](./tour-assets/route-transition/animated.gif)",
      "pattern": "^[^\\S\\n]*this\\.route\\('routes', function \\(\\) \\{"
    },
    {
      "file": "demo-app/app/templates/routes.hbs",
      "description": "# Background - parent route template\nHere's the template for the parent route - simple static HTML with an outlet for child route contents. ",
      "line": 23
    },
    {
      "file": "demo-app/app/templates/routes/index.hbs",
      "description": "# Background - index route template\nIn `routes.index`, we have a `LinkTo` that will bring us to `routes.other` when clicked. Here's what the link looks like:\n\n![Preview of the link content in /routes](./tour-assets/route-transition/index-button.jpg)",
      "line": 6
    },
    {
      "file": "demo-app/app/templates/routes/other.hbs",
      "description": "# Background - other route template\nIn `routes.other`, we have a `LinkTo` that will bring us to `routes.index` when clicked. Here's what the link looks like:\n\n![Preview of the link content in /routes](./tour-assets/route-transition/other-button.jpg)",
      "pattern": "^[^\\S\\n]*</div>"
    },
    {
      "file": "demo-app/app/templates/routes.hbs",
      "description": "# AnimationContext\nLet's get to the API for creating an animation. We're back in the parent template. To create an animation, we first need an `AnimationContext`. This component is responsible for detecting when Ember is re-rendering its contents, and deciding how to animate them based on the function that we pass to `@use`.",
      "pattern": "^[^\\S\\n]*<AnimationContext @id=\"routes-context\" @use=\\{\\{this\\.transition\\}\\} class=\"w-1/4 m-auto mt-5 overflow-hidden\">",
      "title": "AnimationContext"
    },
    {
      "file": "demo-app/app/templates/routes/index.hbs",
      "description": "# Sprite for the index route\nThe `AnimationContext` doesn't try to animate all of its contents. It only manages selected descendants in the DOM tree, that are marked with a `sprite` modifier, that you can see above. The `sprite` modifier provides a way to keep track of a DOM element's changes in styles, so that we can animate them. It is processed to create a sprite, an object which holds a reference to the modifier's DOM element, and stores information about its position, size, and other styling, that is updated with each render. This makes it convenient to specify detailed animations that account for current and future states of the DOM element the sprite manages.\n\nTo make it easier to find a particular sprite when animating, you can pass an `id` and/or a `role` to the modifier. Here, we're giving this sprite an id so we can identify it as the index route's content, and make it move left as we transition to `routes.other`.",
      "pattern": "^[^\\S\\n]*<div class=\"h-12 bg-indigo\" \\{\\{sprite id=\"route-content-index\"\\}\\}>"
    },
    {
      "file": "demo-app/app/templates/routes/other.hbs",
      "description": "# Sprite for the other route\nThe contents of `routes.other` should also contain a sprite, so that we can animate the route transition both ways. We give this sprite a different `id` from the index route so that we can make it move right when the link is clicked and we transition to `routes.index`.",
      "pattern": "^[^\\S\\n]*<div class=\"h-12 bg-green-light\" \\{\\{sprite id=\"route-content-other\"\\}\\}>"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# The transition function\nThis is the transition function we passed to the `AnimationContext` [earlier](command:codetour.navigateToStep?5). In this case, it is defined as a controller's method since that is the closest containing Javascript context for the `AnimationContext`, but transition functions can be defined as component methods, or even utility functions that are imported wherever they're needed.\n\nMore importantly, transition functions need to handle a single argument - a `Changeset` that holds groups of sprites whose states have changed in the DOM, and a reference to the `AnimationContext` that is handling the transition function.",
      "pattern": "^[^\\S\\n]*async transition\\(changeset: Changeset\\): Promise<void> \\{"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Identifying sprites to animate\nIf you're on `routes.index` and click on the link shown, what happens? \n\nWe would expect to transition to `routes.other`. As that happens, the contents of the `outlet` in the parent template change - the sprite from `routes.index` would be **removed** from the DOM, while the sprite from `routes.other` would be **inserted** into the DOM. The reverse would occur if we clicked on the link in `routes.other`.\n\nHere, we're getting references to the removed sprite and the inserted sprite to animate one as it leaves, and one as it enters. We'll need to use these to set up animations later. ",
      "pattern": "^[^\\S\\n]*let insertedSprite = changeset\\.spriteFor\\(\\{ type: SpriteType\\.Inserted \\}\\);"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Creating an orphan from the removed sprite\nThe removed sprite is scheduled to be removed from the DOM this render. We need to keep it in the DOM until we've finished our animation. To do this, we remove its HTML element  from its original parent, and append it as a descendant of the `AnimationContext`'s HTML element, using `AnimationContext.appendOrphan`. `Sprite.lockStyles` helps to preserve the position and dimensions of the removed sprite after we move it from its original parent to the `AnimationContext`.",
      "pattern": "^[^\\S\\n]*removedSprite\\.lockStyles\\(\\);"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Using the inserted sprite id\nBy identifying the inserted sprite using its id (defined in  the templates for [routes.index](command:codetour.navigateToStep?6) and [routes.other](command:codetour.navigateToStep?7)), we can make the sprites move left when we are transitioning to `routes.other`, and right when transitioning to `routes.index`.",
      "pattern": "^[^\\S\\n]*let moveLeft = insertedSprite\\?\\.id === 'route-content-other';"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Moving the removed sprite out\nHere, we set up the animation for the removed sprite. We're animating its position - its `endX`, or horizontal position, is set so that it will move its full width either left or right, hence hiding it completely, before it is removed from the DOM when the animation completes. Its other positional property (y) is not animated, and will remain the same throughout the animation.",
      "line": 103
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Moving the inserted sprite in\nFor the inserted sprite, we put it its full width away from the viewport, effectively hiding it, and move it towards the position it's meant to be. ",
      "line": 108
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Aside about behaviors\nYou might have noticed a reference to `springBehavior` below. Behaviors are similar to easing functions. `SpringBehavior` makes the animation behave like a spring - it might move slower at the beginning, faster in the middle, and slower at the end, and also have a bit of a bounce.",
      "line": 13
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Compiling and running animations\nOnce we've set up the animations, we use the `runAnimations` utility to compile the animations we've specified to keyframes for the web animations API, then start all the animations at the same time to keep them in sync with each other.",
      "pattern": "^[^\\S\\n]*\\]\\);"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Interruption - Kept sprites\nKept sprites are sprites that were in the DOM the previous render. We get kept sprites in 2 ways:\n\n1. A DOM element that is not removed or inserted has its styles modified in this render.\n2. A rerender that interrupts the animation of a removed sprite, after which the sprite's DOM element should no longer be removed. \n\nIn this case, we only get kept sprites when we interrupt the transition (the 2nd way). In the example below, we click on the link in `routes.index`, then click on the link in `routes.other` before the animation has completed. In this case, we're transitioning back to `routes.index`, and because the link from `routes.index` was present in the previous render, it is now a kept sprite (as opposed to inserted).",
      "pattern": "^[^\\S\\n]*if \\(keptSprites\\.size > 0\\) \\{"
    }
  ]
}