{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "Route transition",
  "steps": [
    {
      "file": "demo-app/app/router.js",
      "description": "# Introduction\nOne common scenario for animation is transitioning from one route to another while preserving shared UI elements. In this demo, we'll be exploring how we can animate a link as we transition from `/routes` to `/routes/other`.\n\n![Shows a page transition. After clicking on the link, the link's old content slides over horizontally to allow new content from the new route to replace it.](./tour-assets/route-transition/animated.gif)",
      "pattern": "^[^\\S\\n]*this\\.route\\('routes', function \\(\\) \\{"
    },
    {
      "file": "demo-app/app/templates/routes.hbs",
      "description": "# Background - parent route template\nHere's the template for the parent route - simple static HTML with an outlet for child route contents. ",
      "line": 23
    },
    {
      "file": "demo-app/app/templates/routes/index.hbs",
      "description": "# Background - index route template\nIn `routes.index`, we have a `LinkTo` that will bring us to `routes.other` when clicked. Here's what the link looks like:\n\n![Preview of the link content in /routes](./tour-assets/route-transition/index-button.jpg)",
      "line": 6
    },
    {
      "file": "demo-app/app/templates/routes/other.hbs",
      "description": "# Background - other route template\nIn `routes.other`, we have a `LinkTo` that will bring us to `routes.index` when clicked. Here's what the link looks like:\n\n![Preview of the link content in /routes](./tour-assets/route-transition/other-button.jpg)",
      "pattern": "^[^\\S\\n]*</div>"
    },
    {
      "file": "demo-app/app/templates/routes.hbs",
      "description": "# AnimationContext\nLet's get to the API for creating an animation. We're back in the parent template. To create an animation, we first need an `AnimationContext`. This component is responsible for detecting when Ember is rerendering its contents, and deciding how to animate them based on the function that we pass to `@use`.",
      "pattern": "^[^\\S\\n]*<AnimationContext @id=\"routes-context\" @use=\\{\\{this\\.transition\\}\\} class=\"w-1/4 m-auto mt-5 overflow-hidden\">",
      "title": "AnimationContext"
    },
    {
      "file": "demo-app/app/templates/routes/index.hbs",
      "description": "# Sprite for the index route\nThe `AnimationContext` doesn't try to animate all of its contents. It only manages selected descendants in the DOM tree, that are marked with a `sprite` modifier, that you can see above. The `sprite` modifier provides a way to keep track of a DOM element's changes in styles, so that we can animate them. It is processed to create a sprite, an object which holds a reference to the modifier's DOM element, and stores information about its position, size, and other styling, that is updated with each render. This makes it convenient to specify detailed animations that account for current and future states of the DOM element the sprite manages.\n\nTo make it easier to find a particular sprite when animating, you can pass an `id` and/or a `role` to the modifier. Here, we're giving this sprite an id so we can identify it as the index route's content, and make it move left as we transition to `routes.other`.",
      "pattern": "^[^\\S\\n]*<div class=\"h-12 bg-indigo\" \\{\\{sprite id=\"route-content-index\"\\}\\}>"
    },
    {
      "file": "demo-app/app/templates/routes/other.hbs",
      "description": "# Sprite for the other route\nThe contents of `routes.other` should also contain a sprite, so that we can animate the route transition both ways. We give this sprite a different `id` from the index route so that we can make it move right when the link is clicked and we transition to `routes.index`.",
      "pattern": "^[^\\S\\n]*<div class=\"h-12 bg-green-light\" \\{\\{sprite id=\"route-content-other\"\\}\\}>"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# The transition function\nThis is the transition function we passed to the `AnimationContext` [earlier](command:codetour.navigateToStep?5). In this case, it is defined as a controller's method, but transition functions can be defined as component methods, or even utility functions that are imported wherever they're needed.\n\nTransition functions need to handle a single argument - a `Changeset` that holds groups of sprites whose states have changed in the DOM, and a reference to the `AnimationContext` that is handling the transition function.",
      "pattern": "^[^\\S\\n]*async transition\\(changeset: Changeset\\): Promise<void> \\{"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Identifying sprites to animate\nIf you're on `routes.index` and click on the link shown, what happens? \n\nWe would expect to transition to `routes.other`. As that happens, the contents of the `outlet` in the parent template change - the sprite from `routes.index` would be **removed** from the DOM, while the sprite from `routes.other` would be **inserted** into the DOM. The reverse would occur if we clicked on the link in `routes.other`.\n\nHere, we're getting references to the removed sprite and the inserted sprite to animate one as it leaves, and one as it enters. We'll need to use these to set up animations later. ",
      "pattern": "^[^\\S\\n]*let insertedSprite = changeset\\.spriteFor\\(\\{ type: SpriteType\\.Inserted \\}\\);"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Creating an orphan from the removed sprite\nThe removed sprite is scheduled to be removed from the DOM this render. We need to keep it in the DOM until we've finished our animation. To do this, we remove its HTML element  from its original parent, and append it as a descendant of the `AnimationContext`'s HTML element, using `AnimationContext.appendOrphan`. `Sprite.lockStyles` helps to preserve the position and dimensions of the removed sprite after we move it from its original parent to the `AnimationContext`.",
      "pattern": "^[^\\S\\n]*removedSprite\\.lockStyles\\(\\);"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Using the inserted sprite id\nBy identifying the inserted sprite using its id (defined in  the templates for [routes.index](command:codetour.navigateToStep?6) and [routes.other](command:codetour.navigateToStep?7)), we can make the sprites move left when we are transitioning to `routes.other`, and right when transitioning to `routes.index`.",
      "pattern": "^[^\\S\\n]*let moveLeft = insertedSprite\\?\\.id === 'route-content-other';"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Moving the removed sprite out\nWe're finally going to tell our sprites how to move! Here, we're animating the removed sprite by making it move its full width horizontally, exiting the visible area of the `outlet` it lives in. For this, we use the `'position'` animation.\n\nThis animation allows us to specify `startX`, `startY`, `endX`, and `endY`. These are positions relative to the sprite's current position. \n\nBecause we want the sprite to start at its initial position when animating, there's no need to specify `startX` or `startY`. We also don't want to change the vertical position of the sprite, so we don't specify `endY` either. We only specify an `endX` equal to its width (or negative of its width) to achieve our goal of getting the sprite to slide out of view.",
      "line": 80
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Moving the inserted sprite in\nWe do the same as the [previous step](command:codetour.navigateToStep?12) here, since both the inserted sprite and the removed sprite are moving in the same direction, and have the same width.",
      "line": 85
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Aside about behaviors\nYou might have noticed a reference to `springBehavior` below. Behaviors provide easing for our animations. `SpringBehavior` makes the animation behave like a spring - it might move slower at the beginning, faster in the middle, slower at the end, and also have a bit of a bounce. There's also a `LinearBehavior` that would make our sprite move at the same speed throughout the animation.",
      "line": 13
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Compiling and running animations\nOnce we've set up the animations, we use the `runAnimations` utility to compile the animations we've specified to keyframes for the web animations API, then start all the animations at the same time to keep them in sync with each other.",
      "pattern": "^[^\\S\\n]*\\]\\);"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Interruption\nIf you click on a link as it's animating in, we try to move it back out of view and bring the previous one back into view smoothly. We call this an interruption. For this interruption, we introduce a new sprite type in addition to removed and inserted sprites - kept sprites. \n\nKept sprites are sprites that were in the DOM the previous render. We get kept sprites in 2 ways:\n\n1. A DOM element that is not removed or inserted has its styles modified in this render.\n2. A rerender that interrupts the animation of a removed sprite, after which the sprite's DOM element should no longer be removed. \n\nIn this case, we only get kept sprites when we interrupt the transition (the 2nd way) - so if we see a kept sprite, we know we're dealing with an interruption. ",
      "pattern": "^[^\\S\\n]*if \\(keptSprites\\.size > 0\\) \\{"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Accounting for position mid-animation\nFor the interruption to appear smooth, we need to start the animation right where the previous one was interrupted. This is the X at the start of this render, and is available as `removedSprite.initialBounds.relativeToContext.x`.",
      "pattern": "^[^\\S\\n]*startX: initialBounds\\.x,",
      "selection": {
        "start": {
          "line": 73,
          "character": 29
        },
        "end": {
          "line": 73,
          "character": 34
        }
      },
      "line": 54
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Determining the end position\nSimilar to [what we did with the inserted sprite's id](command:codetour.navigateToStep?11), we use the kept sprite's id to tell if we should move left (-1) or right (1) and multiply that by the width of the removed sprite.",
      "pattern": "^[^\\S\\n]*endX: \\(moveLeft \\? -1 : 1\\) \\* initialBounds\\.width,"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Magic Move\nMagic move is a utility that sets up `'position'` animations on kept sprites. It uses the sprite's current position (accounting for state mid-animation), and final position, and interpolates between them to generate a smooth animation without you having to provide specific start and end points.",
      "pattern": "^[^\\S\\n]*magicMove\\(changeset, \\{"
    },
    {
      "file": "demo-app/app/controllers/routes.ts",
      "description": "# Back to the end\nJust like [the uninterrupted case](command:codetour.navigateToStep?15), we need to start our animations using `runAnimations`. That's it for this animation!",
      "pattern": "^[^\\S\\n]*await runAnimations\\(\\["
    }
  ]
}